1、有关宏的一点处理

①、用const常量替换宏：避免由于预处理器操作，编译器未得到宏变量，导致编译错误；避免产生更大的目标码。

特殊情况1：定义常量指针，常量应定义在头文件中，因此定义指向常量的指针应该为
const char * const name = "sahdaskja"或者
const std::string name("nandnasidni");
(有关const和*的混合使用见第2点)

特殊情况2：对于类专属的常量，应该类内声明（static const int NumInt），类外定义;
可以出现“in-class初值设定”，但是不能实现取地址，只能通过类外定义静态const变量实现类的专属常量定义；

②、当class编译期间需要class常量时，请注意使用enum实现编译期间对class常量的使用；

原因有：1、实现编译期间对class的使用；2、防止外部通过pointer和reference对整数常量的引用或指向；3、enum hack是template编程的基础；

③、避免出现宏定义实现函数，应使用内联函数inline实现相应定义，以免出现宏整体代换缺失括号或先天设计错误导致结果错误；

#ifdef 标识符      ——条件编译

程序段1

#else

程序段2

#endif


2、有关const和*的一点总结

const和***对于变量的修饰遵循“左值右址”不变原则，即const修饰距离其最近的对象。const出现在**左端，表明指针指向的值为常量，指针可变；否则是常量指针，指向的值可变。

Bjane的方法：以*为界，从右向左读

const  char * p——p是指针，指向常量字符，是指针常量

char * const p——p是常量指针，指向是字符；

常量指针：常量，常量的值是指针，即指针不可改变，按照变量就近原则对照

指针常量：指针，指针指向的值是常量，不可改变

2、const关键字：

①、class外修饰global和namespace的常量

②、修饰文件、函数、区块作用域被声明为static的对象

③、修饰class中的static和non-static变量

const与函数声明的使用：函数返回值（防止返回对象的值被改变）、函数参数（参数不改变时尽量使用const参数）、函数自身（成员函数）

const成员函数——处理取得（并经修饰而成）const对象，实现pass-by-reference-const传参

non-const函数调用const函数可以实现non-const函数：

1、对象进行const转换，表明调用const函数；2、const_cast去除调用const函数带来的const特性；3、由于使用non-const对象到const对象的安全转型，使用static_cast转换

3、四种强制类型转换的总结

const_static:去除对象的const、volitale属性

static_cast：转换时不进行安全检查

上行转换：子类指针转换为父类指针（安全转换）；

下行转换：父类指针转换为派生类（不安全转换）；

基本数据类型转化（短类型向长类型转换）；

空指针转为目标类型的空指针;

任何类型的表达式转换为void类型

dynamic_cast:运行时类型安全检查需要运行时类型信息，存储在基类的虚函数表（转换失败返回NULL）

把expression转换成type_id类型的对象。type_id必须是类的指针、引用或者void*；

上行转换同static_cast

下行转换会进行类型检查，比static_cast安全——多态特性的基类转换为派生类，但返回结果时NULL；何时转化成功？？？？

reinterpreter_cast:重新解释类型，但未进行二进制上的转换；

转换的类型必须是一个指针、引用、算术类型、函数指针或者成员指针；

最普通的用途就是在函数指针类型之间进行转换

4、确定对象使用前已经被初始化，防止不明确行为

内置类型定义时完成初始化工作；

非内置类型利用构造函数实现对象的初始化；

对象的成员变量的初始化发生在进入构造函数本体之前——利用初始化列表完成初始化classname::classname(参数1，参数2):变量1（参数1），变量2（参数2），变量为非内置类型则实现copy构造。
在初始化列表中列出所有成员变量

成员变量是const或这reference一定需要初始化

成员初始化次序：基类早于派生类被初始化；class变量以声明顺序被初始化，即使在初始化列表中的顺序不一致，但仍必须按照声明顺序进行。

non-local static对象的初始化次序：

static对象：global对象、定义于namespace作用域的对象、class,函数，file中被声明为static的对象；函数内static对象是local对象，其余是non-local对象（相对于函数而言），static对象的析构函数实现销毁。

编译单元：产生单一目标文件的源码——单一源码文件+头文件

C++对于不同编译单元的non-local static对象初始化次序无明确定义；

解决方法：non-local static搬回自己的专属函数，此函数内对象声明为static对象（第一行定义并初始化，第二行返回对象）中，并返回reference指向所含的对象，用户调用函数实现对non-local static对象的间接调用，对于函数不涉及次序——函数内的local static对象会在函数被调用期间首次遇到对象的定义式时初始化

5、C++构造、析构和赋值运算

①、默默调用的函数：default构造函数、析构函数、copy构造函数、copy赋值运算符——编译器创建的版本只是单纯的将来源对象的每一个non-static成员变量拷贝到目标对象

copy赋值运算符：对于内含“reference和const“成员的class支持赋值操作，那么必须自己定义copy赋值运算符；

②、不使用编译器自动生成的函数，明确拒绝——编译器自动产生的函数（默认为public）声明为private，但是并不实现相应的函数   ？？？？？？还得再理解，定义一个基类，声明其拒绝的函数为private，当前使用的类private（？？？？为何非得是私有继承）继承自该基类，由于private的特性，编译器拒绝调用基类的相应函数；

③、多态基类声明virtual 析构函数

派生类对象经由基类指针删除，但基类析构函数非虚，导致基类指针删除其指向基类的部分，但对象的派生类部分并未被销毁，产生局部销毁现象，导致资源泄露、败坏数据结构。

任何class只要带virtual函数确定会有virtual析构函数；

class不是基类时，不会有virtual的析构函数；

对象携带虚函数表，通过指向函数指针的数组确定运行时哪一个虚函数被调用；

拒绝继承标准容器或不带virtual的析构函数的类；例如子类继承自标准容器或不带virtual的基类，当指向子类的指针转换为指向基类的指针，再次删除指针会导致“行为不明确”

析构函数的运作方式：最深层的派生类的析构函数最先被调用，再逐层调用每个基类的析构函数。当用纯虚析构函数定义抽象类时，应为析构函数提供一份定义。

给基类一个virtual析构函数只适用于多态性质的基类——通过基类指针指向派生类，根据具体调用确定指向。

④、别让异常逃离析构函数

析构函数中抛出异常，即使是并未使用容器或array或者TR1（？？？？？这种情况下的例子），程序也会过早结束或出现不明确行为。
对于析构函数调用的函数可能抛出异常，析构函数应捕获所有异常，并不传播或结束程序

析构函数必须执行一个操作，但可能会在操作失败时抛出异常：

解决方法：1、若抛出异常就结束程序，std::abort()

2、设计接口，实现处理自己管理的类中出现异常，但在原来析构函数中并不调用操作失败

⑤、决不在构造和析构函数中调用virtual函数

基类构造函数早于派生类构造函数调用，基类构造期间virtual函数不是virtual函数，并不能实现多态，即使对象是派生类对象——解释：当基类构造函数执行时，派生类对象并未初始化，因此virtual函数不会下降至派生类，运行期类型信息（dynamic，typeid）会将对象视为基类类型。

重要：利用辅助函数创建值并传递给基类构造函数比直接通过初始化列表传递更加方便，同时辅助函数声明为static，保证不会出现意外指向“初期未成熟之派生类对象尚未初始话的成员变量”，这样也就保证了基类构造和析构函数期间virtual函数下降至派生类。

⑥、operator=返回reference to * this

目的：实现重载运算符的连续赋值

运算符重载时，参数由于*this指针的存在会少一个

⑦、operator=处理自我赋值

自我赋值包括：指针指向同一块内存，自身赋值，别名与自身之间，两个对象来自同一个继承体系

改进：

初级——证同测试实现自我赋值的检验

    问题：未处理new的异常——若内存不够或由于复制构造函数的问题导致new失败，会存在一个始终指向被删除的对象的指针
    
进阶1——复制pb所指东西之前不要删除pb，即先保存pb，赋值之后再删除

进阶2——使用copy and swap技术

⑧、复制对象不要忘记每一个成分

实现自己的copying函数（copy构造函数和copy assignment操作符）特别注意应对对象中的每个成分实现复制，不然编译器不会出现提醒（未采用编译器默认的copying函数）

重要：继承体系中，继承类中不但存在自身的变量还有来自基类的变量，因此初始化成员列表中还应当有传向基类的构造函数，主要针对copy构造函数，初始化列表中应让派生类的构造函数调用基类的构造函数

总结：copying函数确保：1、复制所有的local变量；2、调用所有基类的适当的copying函数

千万不要在copy assignment操作符中调用copy构造函数（相当于试图构造已经存在的对象）
若两者代码相似，消除重复最好的办法时是通过initial函数调用两个函数


